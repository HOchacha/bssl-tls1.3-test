/*
 * WARNING: do not edit!
 * Generated by Makefile from ../../../openssl/source/include/openssl/ct.h.in
 *
 * Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */



#ifndef ossl_OPENSSL_CT_H
# define ossl_OPENSSL_CT_H
# pragma once

# include "ossl/openssl/macros.h"
# ifndef ossl_OPENSSL_NO_DEPRECATED_3_0
#  define ossl_HEADER_CT_H
# endif

# include "ossl/openssl/opensslconf.h"

# ifndef ossl_OPENSSL_NO_CT
# include "ossl/openssl/types.h"
# include "ossl/openssl/safestack.h"
# include "ossl/openssl/x509.h"
# include "ossl/openssl/cterr.h"
# ifdef  __cplusplus
extern "C" {
# endif


/* Minimum ossl_RSA key size, from RFC6962 */
# define ossl_SCT_MIN_RSA_BITS 2048

/* All hashes are ossl_SHA256 in v1 of Certificate Transparency */
# define ossl_CT_V1_HASHLEN ossl_SHA256_DIGEST_LENGTH

ossl_SKM_DEFINE_STACK_OF_INTERNAL(ossl_SCT, ossl_SCT, ossl_SCT)
#define ossl_sk_SCT_num(sk) ossl_OPENSSL_sk_num(ossl_ossl_check_const_SCT_sk_type(sk))
#define ossl_sk_SCT_value(sk, idx) ((ossl_SCT *)ossl_OPENSSL_sk_value(ossl_ossl_check_const_SCT_sk_type(sk), (idx)))
#define ossl_sk_SCT_new(cmp) ((ossl_STACK_OF(ossl_SCT) *)ossl_OPENSSL_sk_new(ossl_ossl_check_SCT_compfunc_type(cmp)))
#define ossl_sk_SCT_new_null() ((ossl_STACK_OF(ossl_SCT) *)ossl_OPENSSL_sk_new_null())
#define ossl_sk_SCT_new_reserve(cmp, n) ((ossl_STACK_OF(ossl_SCT) *)ossl_OPENSSL_sk_new_reserve(ossl_ossl_check_SCT_compfunc_type(cmp), (n)))
#define ossl_sk_SCT_reserve(sk, n) ossl_OPENSSL_sk_reserve(ossl_ossl_check_SCT_sk_type(sk), (n))
#define ossl_sk_SCT_free(sk) ossl_OPENSSL_sk_free(ossl_ossl_check_SCT_sk_type(sk))
#define ossl_sk_SCT_zero(sk) ossl_OPENSSL_sk_zero(ossl_ossl_check_SCT_sk_type(sk))
#define ossl_sk_SCT_delete(sk, i) ((ossl_SCT *)ossl_OPENSSL_sk_delete(ossl_ossl_check_SCT_sk_type(sk), (i)))
#define ossl_sk_SCT_delete_ptr(sk, ptr) ((ossl_SCT *)ossl_OPENSSL_sk_delete_ptr(ossl_ossl_check_SCT_sk_type(sk), ossl_ossl_check_SCT_type(ptr)))
#define ossl_sk_SCT_push(sk, ptr) ossl_OPENSSL_sk_push(ossl_ossl_check_SCT_sk_type(sk), ossl_ossl_check_SCT_type(ptr))
#define ossl_sk_SCT_unshift(sk, ptr) ossl_OPENSSL_sk_unshift(ossl_ossl_check_SCT_sk_type(sk), ossl_ossl_check_SCT_type(ptr))
#define ossl_sk_SCT_pop(sk) ((ossl_SCT *)ossl_OPENSSL_sk_pop(ossl_ossl_check_SCT_sk_type(sk)))
#define ossl_sk_SCT_shift(sk) ((ossl_SCT *)ossl_OPENSSL_sk_shift(ossl_ossl_check_SCT_sk_type(sk)))
#define ossl_sk_SCT_pop_free(sk, freefunc) ossl_OPENSSL_sk_pop_free(ossl_ossl_check_SCT_sk_type(sk),ossl_ossl_check_SCT_freefunc_type(freefunc))
#define ossl_sk_SCT_insert(sk, ptr, idx) ossl_OPENSSL_sk_insert(ossl_ossl_check_SCT_sk_type(sk), ossl_ossl_check_SCT_type(ptr), (idx))
#define ossl_sk_SCT_set(sk, idx, ptr) ((ossl_SCT *)ossl_OPENSSL_sk_set(ossl_ossl_check_SCT_sk_type(sk), (idx), ossl_ossl_check_SCT_type(ptr)))
#define ossl_sk_SCT_find(sk, ptr) ossl_OPENSSL_sk_find(ossl_ossl_check_SCT_sk_type(sk), ossl_ossl_check_SCT_type(ptr))
#define ossl_sk_SCT_find_ex(sk, ptr) ossl_OPENSSL_sk_find_ex(ossl_ossl_check_SCT_sk_type(sk), ossl_ossl_check_SCT_type(ptr))
#define ossl_sk_SCT_find_all(sk, ptr, pnum) ossl_OPENSSL_sk_find_all(ossl_ossl_check_SCT_sk_type(sk), ossl_ossl_check_SCT_type(ptr), pnum)
#define ossl_sk_SCT_sort(sk) ossl_OPENSSL_sk_sort(ossl_ossl_check_SCT_sk_type(sk))
#define ossl_sk_SCT_is_sorted(sk) ossl_OPENSSL_sk_is_sorted(ossl_ossl_check_const_SCT_sk_type(sk))
#define ossl_sk_SCT_dup(sk) ((ossl_STACK_OF(ossl_SCT) *)ossl_OPENSSL_sk_dup(ossl_ossl_check_const_SCT_sk_type(sk)))
#define ossl_sk_SCT_deep_copy(sk, copyfunc, freefunc) ((ossl_STACK_OF(ossl_SCT) *)ossl_OPENSSL_sk_deep_copy(ossl_ossl_check_const_SCT_sk_type(sk), ossl_ossl_check_SCT_copyfunc_type(copyfunc), ossl_ossl_check_SCT_freefunc_type(freefunc)))
#define ossl_sk_SCT_set_cmp_func(sk, cmp) ((ossl_sk_SCT_compfunc)ossl_OPENSSL_sk_set_cmp_func(ossl_ossl_check_SCT_sk_type(sk), ossl_ossl_check_SCT_compfunc_type(cmp)))
ossl_SKM_DEFINE_STACK_OF_INTERNAL(ossl_CTLOG, ossl_CTLOG, ossl_CTLOG)
#define ossl_sk_CTLOG_num(sk) ossl_OPENSSL_sk_num(ossl_ossl_check_const_CTLOG_sk_type(sk))
#define ossl_sk_CTLOG_value(sk, idx) ((ossl_CTLOG *)ossl_OPENSSL_sk_value(ossl_ossl_check_const_CTLOG_sk_type(sk), (idx)))
#define ossl_sk_CTLOG_new(cmp) ((ossl_STACK_OF(ossl_CTLOG) *)ossl_OPENSSL_sk_new(ossl_ossl_check_CTLOG_compfunc_type(cmp)))
#define ossl_sk_CTLOG_new_null() ((ossl_STACK_OF(ossl_CTLOG) *)ossl_OPENSSL_sk_new_null())
#define ossl_sk_CTLOG_new_reserve(cmp, n) ((ossl_STACK_OF(ossl_CTLOG) *)ossl_OPENSSL_sk_new_reserve(ossl_ossl_check_CTLOG_compfunc_type(cmp), (n)))
#define ossl_sk_CTLOG_reserve(sk, n) ossl_OPENSSL_sk_reserve(ossl_ossl_check_CTLOG_sk_type(sk), (n))
#define ossl_sk_CTLOG_free(sk) ossl_OPENSSL_sk_free(ossl_ossl_check_CTLOG_sk_type(sk))
#define ossl_sk_CTLOG_zero(sk) ossl_OPENSSL_sk_zero(ossl_ossl_check_CTLOG_sk_type(sk))
#define ossl_sk_CTLOG_delete(sk, i) ((ossl_CTLOG *)ossl_OPENSSL_sk_delete(ossl_ossl_check_CTLOG_sk_type(sk), (i)))
#define ossl_sk_CTLOG_delete_ptr(sk, ptr) ((ossl_CTLOG *)ossl_OPENSSL_sk_delete_ptr(ossl_ossl_check_CTLOG_sk_type(sk), ossl_ossl_check_CTLOG_type(ptr)))
#define ossl_sk_CTLOG_push(sk, ptr) ossl_OPENSSL_sk_push(ossl_ossl_check_CTLOG_sk_type(sk), ossl_ossl_check_CTLOG_type(ptr))
#define ossl_sk_CTLOG_unshift(sk, ptr) ossl_OPENSSL_sk_unshift(ossl_ossl_check_CTLOG_sk_type(sk), ossl_ossl_check_CTLOG_type(ptr))
#define ossl_sk_CTLOG_pop(sk) ((ossl_CTLOG *)ossl_OPENSSL_sk_pop(ossl_ossl_check_CTLOG_sk_type(sk)))
#define ossl_sk_CTLOG_shift(sk) ((ossl_CTLOG *)ossl_OPENSSL_sk_shift(ossl_ossl_check_CTLOG_sk_type(sk)))
#define ossl_sk_CTLOG_pop_free(sk, freefunc) ossl_OPENSSL_sk_pop_free(ossl_ossl_check_CTLOG_sk_type(sk),ossl_ossl_check_CTLOG_freefunc_type(freefunc))
#define ossl_sk_CTLOG_insert(sk, ptr, idx) ossl_OPENSSL_sk_insert(ossl_ossl_check_CTLOG_sk_type(sk), ossl_ossl_check_CTLOG_type(ptr), (idx))
#define ossl_sk_CTLOG_set(sk, idx, ptr) ((ossl_CTLOG *)ossl_OPENSSL_sk_set(ossl_ossl_check_CTLOG_sk_type(sk), (idx), ossl_ossl_check_CTLOG_type(ptr)))
#define ossl_sk_CTLOG_find(sk, ptr) ossl_OPENSSL_sk_find(ossl_ossl_check_CTLOG_sk_type(sk), ossl_ossl_check_CTLOG_type(ptr))
#define ossl_sk_CTLOG_find_ex(sk, ptr) ossl_OPENSSL_sk_find_ex(ossl_ossl_check_CTLOG_sk_type(sk), ossl_ossl_check_CTLOG_type(ptr))
#define ossl_sk_CTLOG_find_all(sk, ptr, pnum) ossl_OPENSSL_sk_find_all(ossl_ossl_check_CTLOG_sk_type(sk), ossl_ossl_check_CTLOG_type(ptr), pnum)
#define ossl_sk_CTLOG_sort(sk) ossl_OPENSSL_sk_sort(ossl_ossl_check_CTLOG_sk_type(sk))
#define ossl_sk_CTLOG_is_sorted(sk) ossl_OPENSSL_sk_is_sorted(ossl_ossl_check_const_CTLOG_sk_type(sk))
#define ossl_sk_CTLOG_dup(sk) ((ossl_STACK_OF(ossl_CTLOG) *)ossl_OPENSSL_sk_dup(ossl_ossl_check_const_CTLOG_sk_type(sk)))
#define ossl_sk_CTLOG_deep_copy(sk, copyfunc, freefunc) ((ossl_STACK_OF(ossl_CTLOG) *)ossl_OPENSSL_sk_deep_copy(ossl_ossl_check_const_CTLOG_sk_type(sk), ossl_ossl_check_CTLOG_copyfunc_type(copyfunc), ossl_ossl_check_CTLOG_freefunc_type(freefunc)))
#define ossl_sk_CTLOG_set_cmp_func(sk, cmp) ((ossl_sk_CTLOG_compfunc)ossl_OPENSSL_sk_set_cmp_func(ossl_ossl_check_CTLOG_sk_type(sk), ossl_ossl_check_CTLOG_compfunc_type(cmp)))



typedef enum {
    ossl_CT_LOG_ENTRY_TYPE_NOT_SET = -1,
    ossl_CT_LOG_ENTRY_TYPE_X509 = 0,
    ossl_CT_LOG_ENTRY_TYPE_PRECERT = 1
} ossl_ct_log_entry_type_t;

typedef enum {
    ossl_SCT_VERSION_NOT_SET = -1,
    ossl_SCT_VERSION_V1 = 0
} ossl_sct_version_t;

typedef enum {
    ossl_SCT_SOURCE_UNKNOWN,
    ossl_SCT_SOURCE_TLS_EXTENSION,
    ossl_SCT_SOURCE_X509V3_EXTENSION,
    ossl_SCT_SOURCE_OCSP_STAPLED_RESPONSE
} ossl_sct_source_t;

typedef enum {
    ossl_SCT_VALIDATION_STATUS_NOT_SET,
    ossl_SCT_VALIDATION_STATUS_UNKNOWN_LOG,
    ossl_SCT_VALIDATION_STATUS_VALID,
    ossl_SCT_VALIDATION_STATUS_INVALID,
    ossl_SCT_VALIDATION_STATUS_UNVERIFIED,
    ossl_SCT_VALIDATION_STATUS_UNKNOWN_VERSION
} ossl_sct_validation_status_t;

/******************************************
 * CT policy evaluation context functions *
 ******************************************/

/*
 * Creates a new, empty policy evaluation context associated with the given
 * library context and property query string.
 * The caller is responsible for calling ossl_CT_POLICY_EVAL_CTX_free when finished
 * with the ossl_CT_POLICY_EVAL_CTX.
 */
ossl_CT_POLICY_EVAL_CTX *ossl_CT_POLICY_EVAL_CTX_new_ex(ossl_OSSL_LIB_CTX *libctx,
                                              const char *propq);
                                                       
/*
 * The same as ossl_CT_POLICY_EVAL_CTX_new_ex() but the default library
 * context and property query string is used.
 */
ossl_CT_POLICY_EVAL_CTX *ossl_CT_POLICY_EVAL_CTX_new(void);

/* Deletes a policy evaluation context and anything it owns. */
void ossl_CT_POLICY_EVAL_CTX_free(ossl_CT_POLICY_EVAL_CTX *ctx);

/* Gets the peer certificate that the SCTs are for */
ossl_X509* ossl_CT_POLICY_EVAL_CTX_get0_cert(const ossl_CT_POLICY_EVAL_CTX *ctx);

/*
 * Sets the certificate associated with the received SCTs.
 * Increments the reference count of cert.
 * Returns 1 on success, 0 otherwise.
 */
int ossl_CT_POLICY_EVAL_CTX_set1_cert(ossl_CT_POLICY_EVAL_CTX *ctx, ossl_X509 *cert);

/* Gets the issuer of the aforementioned certificate */
ossl_X509* ossl_CT_POLICY_EVAL_CTX_get0_issuer(const ossl_CT_POLICY_EVAL_CTX *ctx);

/*
 * Sets the issuer of the certificate associated with the received SCTs.
 * Increments the reference count of issuer.
 * Returns 1 on success, 0 otherwise.
 */
int ossl_CT_POLICY_EVAL_CTX_set1_issuer(ossl_CT_POLICY_EVAL_CTX *ctx, ossl_X509 *issuer);

/* Gets the CT logs that are trusted sources of SCTs */
const ossl_CTLOG_STORE *ossl_CT_POLICY_EVAL_CTX_get0_log_store(const ossl_CT_POLICY_EVAL_CTX *ctx);

/* Sets the log store that is in use. It must outlive the ossl_CT_POLICY_EVAL_CTX. */
void ossl_CT_POLICY_EVAL_CTX_set_shared_CTLOG_STORE(ossl_CT_POLICY_EVAL_CTX *ctx,
                                               ossl_CTLOG_STORE *log_store);

/*
 * Gets the time, in milliseconds since the Unix epoch, that will be used as the
 * current time when checking whether an ossl_SCT was issued in the future.
 * Such SCTs will fail validation, as required by RFC6962.
 */
uint64_t ossl_CT_POLICY_EVAL_CTX_get_time(const ossl_CT_POLICY_EVAL_CTX *ctx);

/*
 * Sets the time to evaluate SCTs against, in milliseconds since the Unix epoch.
 * If an ossl_SCT's timestamp is after this time, it will be interpreted as having
 * been issued in the future. RFC6962 states that "TLS clients MUST reject SCTs
 * whose timestamp is in the future", so an ossl_SCT will not validate in this case.
 */
void ossl_CT_POLICY_EVAL_CTX_set_time(ossl_CT_POLICY_EVAL_CTX *ctx, uint64_t time_in_ms);

/*****************
 * ossl_SCT functions *
 *****************/

/*
 * Creates a new, blank ossl_SCT.
 * The caller is responsible for calling ossl_SCT_free when finished with the ossl_SCT.
 */
ossl_SCT *ossl_SCT_new(void);

/*
 * Creates a new ossl_SCT from some base64-encoded strings.
 * The caller is responsible for calling ossl_SCT_free when finished with the ossl_SCT.
 */
ossl_SCT *ossl_SCT_new_from_base64(unsigned char version,
                         const char *logid_base64,
                         ossl_ct_log_entry_type_t entry_type,
                         uint64_t timestamp,
                         const char *extensions_base64,
                         const char *signature_base64);

/*
 * Frees the ossl_SCT and the underlying data structures.
 */
void ossl_SCT_free(ossl_SCT *sct);

/*
 * Free a stack of SCTs, and the underlying SCTs themselves.
 * Intended to be compatible with ossl_X509V3_EXT_FREE.
 */
void ossl_SCT_LIST_free(ossl_STACK_OF(ossl_SCT) *a);

/*
 * Returns the version of the ossl_SCT.
 */
ossl_sct_version_t ossl_SCT_get_version(const ossl_SCT *sct);

/*
 * Set the version of an ossl_SCT.
 * Returns 1 on success, 0 if the version is unrecognized.
 */
ossl___owur int ossl_SCT_set_version(ossl_SCT *sct, ossl_sct_version_t version);

/*
 * Returns the log entry type of the ossl_SCT.
 */
ossl_ct_log_entry_type_t ossl_SCT_get_log_entry_type(const ossl_SCT *sct);

/*
 * Set the log entry type of an ossl_SCT.
 * Returns 1 on success, 0 otherwise.
 */
ossl___owur int ossl_SCT_set_log_entry_type(ossl_SCT *sct, ossl_ct_log_entry_type_t entry_type);

/*
 * Gets the ID of the log that an ossl_SCT came from.
 * Ownership of the log ID remains with the ossl_SCT.
 * Returns the length of the log ID.
 */
size_t ossl_SCT_get0_log_id(const ossl_SCT *sct, unsigned char **log_id);

/*
 * Set the log ID of an ossl_SCT to point directly to the *log_id specified.
 * The ossl_SCT takes ownership of the specified pointer.
 * Returns 1 on success, 0 otherwise.
 */
ossl___owur int ossl_SCT_set0_log_id(ossl_SCT *sct, unsigned char *log_id, size_t log_id_len);

/*
 * Set the log ID of an ossl_SCT.
 * This makes a copy of the log_id.
 * Returns 1 on success, 0 otherwise.
 */
ossl___owur int ossl_SCT_set1_log_id(ossl_SCT *sct, const unsigned char *log_id,
                           size_t log_id_len);

/*
 * Returns the timestamp for the ossl_SCT (epoch time in milliseconds).
 */
uint64_t ossl_SCT_get_timestamp(const ossl_SCT *sct);

/*
 * Set the timestamp of an ossl_SCT (epoch time in milliseconds).
 */
void ossl_SCT_set_timestamp(ossl_SCT *sct, uint64_t timestamp);

/*
 * Return the NID for the signature used by the ossl_SCT.
 * For CT v1, this will be either ossl_NID_sha256WithRSAEncryption or
 * ossl_NID_ecdsa_with_SHA256 (or ossl_NID_undef if incorrect/unset).
 */
int ossl_SCT_get_signature_nid(const ossl_SCT *sct);

/*
 * Set the signature type of an ossl_SCT
 * For CT v1, this should be either ossl_NID_sha256WithRSAEncryption or
 * ossl_NID_ecdsa_with_SHA256.
 * Returns 1 on success, 0 otherwise.
 */
ossl___owur int ossl_SCT_set_signature_nid(ossl_SCT *sct, int nid);

/*
 * Set *ext to point to the extension data for the ossl_SCT. ext must not be NULL.
 * The ossl_SCT retains ownership of this pointer.
 * Returns length of the data pointed to.
 */
size_t ossl_SCT_get0_extensions(const ossl_SCT *sct, unsigned char **ext);

/*
 * Set the extensions of an ossl_SCT to point directly to the *ext specified.
 * The ossl_SCT takes ownership of the specified pointer.
 */
void ossl_SCT_set0_extensions(ossl_SCT *sct, unsigned char *ext, size_t ext_len);

/*
 * Set the extensions of an ossl_SCT.
 * This takes a copy of the ext.
 * Returns 1 on success, 0 otherwise.
 */
ossl___owur int ossl_SCT_set1_extensions(ossl_SCT *sct, const unsigned char *ext,
                               size_t ext_len);

/*
 * Set *sig to point to the signature for the ossl_SCT. sig must not be NULL.
 * The ossl_SCT retains ownership of this pointer.
 * Returns length of the data pointed to.
 */
size_t ossl_SCT_get0_signature(const ossl_SCT *sct, unsigned char **sig);

/*
 * Set the signature of an ossl_SCT to point directly to the *sig specified.
 * The ossl_SCT takes ownership of the specified pointer.
 */
void ossl_SCT_set0_signature(ossl_SCT *sct, unsigned char *sig, size_t sig_len);

/*
 * Set the signature of an ossl_SCT to be a copy of the *sig specified.
 * Returns 1 on success, 0 otherwise.
 */
ossl___owur int ossl_SCT_set1_signature(ossl_SCT *sct, const unsigned char *sig,
                              size_t sig_len);

/*
 * The origin of this ossl_SCT, e.g. TLS extension, OCSP response, etc.
 */
ossl_sct_source_t ossl_SCT_get_source(const ossl_SCT *sct);

/*
 * Set the origin of this ossl_SCT, e.g. TLS extension, OCSP response, etc.
 * Returns 1 on success, 0 otherwise.
 */
ossl___owur int ossl_SCT_set_source(ossl_SCT *sct, ossl_sct_source_t source);

/*
 * Returns a text string describing the validation status of |sct|.
 */
const char *ossl_SCT_validation_status_string(const ossl_SCT *sct);

/*
 * Pretty-prints an |sct| to |out|.
 * It will be indented by the number of spaces specified by |indent|.
 * If |logs| is not NULL, it will be used to lookup the CT log that the ossl_SCT came
 * from, so that the log name can be printed.
 */
void ossl_SCT_print(const ossl_SCT *sct, ossl_BIO *out, int indent, const ossl_CTLOG_STORE *logs);

/*
 * Pretty-prints an |sct_list| to |out|.
 * It will be indented by the number of spaces specified by |indent|.
 * SCTs will be delimited by |separator|.
 * If |logs| is not NULL, it will be used to lookup the CT log that each ossl_SCT
 * came from, so that the log names can be printed.
 */
void ossl_SCT_LIST_print(const ossl_STACK_OF(ossl_SCT) *sct_list, ossl_BIO *out, int indent,
                    const char *separator, const ossl_CTLOG_STORE *logs);

/*
 * Gets the last result of validating this ossl_SCT.
 * If it has not been validated yet, returns ossl_SCT_VALIDATION_STATUS_NOT_SET.
 */
ossl_sct_validation_status_t ossl_SCT_get_validation_status(const ossl_SCT *sct);

/*
 * Validates the given ossl_SCT with the provided context.
 * Sets the "validation_status" field of the ossl_SCT.
 * Returns 1 if the ossl_SCT is valid and the signature verifies.
 * Returns 0 if the ossl_SCT is invalid or could not be verified.
 * Returns -1 if an error occurs.
 */
ossl___owur int ossl_SCT_validate(ossl_SCT *sct, const ossl_CT_POLICY_EVAL_CTX *ctx);

/*
 * Validates the given list of SCTs with the provided context.
 * Sets the "validation_status" field of each ossl_SCT.
 * Returns 1 if there are no invalid SCTs and all signatures verify.
 * Returns 0 if at least one ossl_SCT is invalid or could not be verified.
 * Returns a negative integer if an error occurs.
 */
ossl___owur int ossl_SCT_LIST_validate(const ossl_STACK_OF(ossl_SCT) *scts,
                             ossl_CT_POLICY_EVAL_CTX *ctx);


/*********************************
 * ossl_SCT parsing and serialization *
 *********************************/

/*
 * Serialize (to TLS format) a stack of SCTs and return the length.
 * "a" must not be NULL.
 * If "pp" is NULL, just return the length of what would have been serialized.
 * If "pp" is not NULL and "*pp" is null, function will allocate a new pointer
 * for data that caller is responsible for freeing (only if function returns
 * successfully).
 * If "pp" is NULL and "*pp" is not NULL, caller is responsible for ensuring
 * that "*pp" is large enough to accept all of the serialized data.
 * Returns < 0 on error, >= 0 indicating bytes written (or would have been)
 * on success.
 */
ossl___owur int ossl_i2o_SCT_LIST(const ossl_STACK_OF(ossl_SCT) *a, unsigned char **pp);

/*
 * Convert TLS format ossl_SCT list to a stack of SCTs.
 * If "a" or "*a" is NULL, a new stack will be created that the caller is
 * responsible for freeing (by calling ossl_SCT_LIST_free).
 * "**pp" and "*pp" must not be NULL.
 * Upon success, "*pp" will point to after the last bytes read, and a stack
 * will be returned.
 * Upon failure, a NULL pointer will be returned, and the position of "*pp" is
 * not defined.
 */
ossl_STACK_OF(ossl_SCT) *ossl_o2i_SCT_LIST(ossl_STACK_OF(ossl_SCT) **a, const unsigned char **pp,
                            size_t len);

/*
 * Serialize (to DER format) a stack of SCTs and return the length.
 * "a" must not be NULL.
 * If "pp" is NULL, just returns the length of what would have been serialized.
 * If "pp" is not NULL and "*pp" is null, function will allocate a new pointer
 * for data that caller is responsible for freeing (only if function returns
 * successfully).
 * If "pp" is NULL and "*pp" is not NULL, caller is responsible for ensuring
 * that "*pp" is large enough to accept all of the serialized data.
 * Returns < 0 on error, >= 0 indicating bytes written (or would have been)
 * on success.
 */
ossl___owur int ossl_i2d_SCT_LIST(const ossl_STACK_OF(ossl_SCT) *a, unsigned char **pp);

/*
 * Parses an ossl_SCT list in DER format and returns it.
 * If "a" or "*a" is NULL, a new stack will be created that the caller is
 * responsible for freeing (by calling ossl_SCT_LIST_free).
 * "**pp" and "*pp" must not be NULL.
 * Upon success, "*pp" will point to after the last bytes read, and a stack
 * will be returned.
 * Upon failure, a NULL pointer will be returned, and the position of "*pp" is
 * not defined.
 */
ossl_STACK_OF(ossl_SCT) *ossl_d2i_SCT_LIST(ossl_STACK_OF(ossl_SCT) **a, const unsigned char **pp,
                            long len);

/*
 * Serialize (to TLS format) an |sct| and write it to |out|.
 * If |out| is null, no ossl_SCT will be output but the length will still be returned.
 * If |out| points to a null pointer, a string will be allocated to hold the
 * TLS-format ossl_SCT. It is the responsibility of the caller to free it.
 * If |out| points to an allocated string, the TLS-format ossl_SCT will be written
 * to it.
 * The length of the ossl_SCT in TLS format will be returned.
 */
ossl___owur int ossl_i2o_SCT(const ossl_SCT *sct, unsigned char **out);

/*
 * Parses an ossl_SCT in TLS format and returns it.
 * If |psct| is not null, it will end up pointing to the parsed ossl_SCT. If it
 * already points to a non-null pointer, the pointer will be free'd.
 * |in| should be a pointer to a string containing the TLS-format ossl_SCT.
 * |in| will be advanced to the end of the ossl_SCT if parsing succeeds.
 * |len| should be the length of the ossl_SCT in |in|.
 * Returns NULL if an error occurs.
 * If the ossl_SCT is an unsupported version, only the ossl_SCT's 'sct' and 'sct_len'
 * fields will be populated (with |in| and |len| respectively).
 */
ossl_SCT *ossl_o2i_SCT(ossl_SCT **psct, const unsigned char **in, size_t len);

/********************
 * CT log functions *
 ********************/

/*
 * Creates a new CT log instance with the given |public_key| and |name| and
 * associates it with the give library context |libctx| and property query
 * string |propq|.
 * Takes ownership of |public_key| but copies |name|.
 * Returns NULL if malloc fails or if |public_key| cannot be converted to DER.
 * Should be deleted by the caller using ossl_CTLOG_free when no longer needed.
 */
ossl_CTLOG *ossl_CTLOG_new_ex(ossl_EVP_PKEY *public_key, const char *name, ossl_OSSL_LIB_CTX *libctx,
                    const char *propq);

/*
 * The same as ossl_CTLOG_new_ex except that the default library context and
 * property query string are used.
 */
ossl_CTLOG *ossl_CTLOG_new(ossl_EVP_PKEY *public_key, const char *name);

/*
 * Creates a new ossl_CTLOG instance with the base64-encoded SubjectPublicKeyInfo DER
 * in |pkey_base64| and associated with the given library context |libctx| and
 * property query string |propq|. The |name| is a string to help users identify
 * this log.
 * Returns 1 on success, 0 on failure.
 * Should be deleted by the caller using ossl_CTLOG_free when no longer needed.
 */
int ossl_CTLOG_new_from_base64_ex(ossl_CTLOG **ct_log, const char *pkey_base64,
                             const char *name, ossl_OSSL_LIB_CTX *libctx,
                             const char *propq);

/*
 * The same as ossl_CTLOG_new_from_base64_ex() except that the default
 * library context and property query string are used.
 * Returns 1 on success, 0 on failure.
 */
int ossl_CTLOG_new_from_base64(ossl_CTLOG ** ct_log,
                          const char *pkey_base64, const char *name);

/*
 * Deletes a CT log instance and its fields.
 */
void ossl_CTLOG_free(ossl_CTLOG *log);

/* Gets the name of the CT log */
const char *ossl_CTLOG_get0_name(const ossl_CTLOG *log);
/* Gets the ID of the CT log */
void ossl_CTLOG_get0_log_id(const ossl_CTLOG *log, const uint8_t **log_id,
                       size_t *log_id_len);
/* Gets the public key of the CT log */
ossl_EVP_PKEY *ossl_CTLOG_get0_public_key(const ossl_CTLOG *log);

/**************************
 * CT log store functions *
 **************************/

/*
 * Creates a new CT log store and associates it with the given libctx and
 * property query string.
 * Should be deleted by the caller using ossl_CTLOG_STORE_free when no longer needed.
 */
ossl_CTLOG_STORE *ossl_CTLOG_STORE_new_ex(ossl_OSSL_LIB_CTX *libctx, const char *propq);

/*
 * Same as ossl_CTLOG_STORE_new_ex except that the default libctx and
 * property query string are used.
 * Should be deleted by the caller using ossl_CTLOG_STORE_free when no longer needed.
 */
ossl_CTLOG_STORE *ossl_CTLOG_STORE_new(void);

/*
 * Deletes a CT log store and all of the CT log instances held within.
 */
void ossl_CTLOG_STORE_free(ossl_CTLOG_STORE *store);

/*
 * Finds a CT log in the store based on its log ID.
 * Returns the CT log, or NULL if no match is found.
 */
const ossl_CTLOG *ossl_CTLOG_STORE_get0_log_by_id(const ossl_CTLOG_STORE *store,
                                        const uint8_t *log_id,
                                        size_t log_id_len);

/*
 * Loads a CT log list into a |store| from a |file|.
 * Returns 1 if loading is successful, or 0 otherwise.
 */
ossl___owur int ossl_CTLOG_STORE_load_file(ossl_CTLOG_STORE *store, const char *file);

/*
 * Loads the default CT log list into a |store|.
 * Returns 1 if loading is successful, or 0 otherwise.
 */
ossl___owur int ossl_CTLOG_STORE_load_default_file(ossl_CTLOG_STORE *store);

#  ifdef  __cplusplus
}
#  endif
# endif
#endif
